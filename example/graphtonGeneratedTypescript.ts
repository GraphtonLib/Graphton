/**
 * FILE GENERATED BY GRAPHTON
 * DO NOT EDIT - CHANGES WILL BE OVERWRITTEN
 * @see https://github.com/GraphtonLib/Graphton
 **/

// REGION: Base classes
export class GraphtonSettings {
  public static headers: Record<string, string> = {};
  public static graphqlEndpoint: string = "";
}

import axios from "axios";
import type { AxiosRequestConfig, AxiosResponse } from "axios";

function applyMixins(derivedCtor: any, constructors: any[]) {
  constructors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      Object.defineProperty(
        derivedCtor.prototype,
        name,
        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null)
      );
    });
  });
}

type RootType = "query" | "mutation" | "subscription";

type ReturnObject = { [p: string]: string | ReturnObject };
export abstract class GraphtonBaseQuery<QueryResponse> {
  public abstract readonly queryName: string;
  public abstract readonly rootType: RootType;

  constructor() {
    this.initGraphtonQueryReturnsObject();
  }

  protected initGraphtonQueryReturnsObject(): void {}

  /**
   * Get the return object format
   */
  public toReturnString(): string {
    return "";
  }

  /**
   * Transform arguments to string to use in query
   */
  protected toArgString(): string {
    return "";
  }

  /**
   * Transform query class to graphql query string
   */
  public toQuery(): string {
    return `${this.rootType} ${this.queryName} { ${this.queryName}${this.toArgString()} ${this.toReturnString()} }`;
  }

  /**
   * Execute the query
   */
  protected async execute(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<QueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    if (requestConfig.headers) {
      requestConfig.headers = {
        ...requestConfig.headers,
        "Content-Type": "application/json",
      };
    }

    const response = await axios.post(
      GraphtonSettings.graphqlEndpoint,
      { query: this.toQuery() },
      {
        headers: {
          "Content-Type": "application/json",
          ...GraphtonSettings.headers,
        },
        ...requestConfig,
      }
    );

    const returnData = {
      ...response.data,
      axiosResponse: response,
    };

    if (returnData.errors) {
      return Promise.reject(returnData);
    }

    return returnData;
  }
}

type FieldSelectorTypeFormat = { [key: string]: {} | FieldSelectorTypeFormat };
export abstract class GraphtonQueryReturnsObject<
  FieldSelectorType extends FieldSelectorTypeFormat,
  ReturnType extends { [p: string]: unknown }
> {
  protected selectedFields!: { root: Partial<FieldSelectorType> };
  protected readonly returnType!: keyof typeof fieldObjectMap;

  protected initGraphtonQueryReturnsObject(): void {
    this.selectedFields = { root: {} };
  }

  /**
   * Select fields that should be returned
   */
  public select(fields: Partial<FieldSelectorType>): this {
    this.doSelect(fields, this.selectedFields.root);

    return this;
  }

  protected doSelect(
    fields: Partial<FieldSelectorType>,
    selectionLevel: Partial<FieldSelectorTypeFormat>,
    lookupType: keyof typeof fieldObjectMap = this.returnType
  ) {
    for (let [field, subSelection] of Object.entries(fields)) {
      if (field === "_all") {
        Object.entries(fieldObjectMap[lookupType])
          .filter(([, v]) => v === null)
          .forEach(([k]) => (selectionLevel[k] = {}));
      } else {
        if (subSelection === undefined) continue;

        let lookupField = fieldObjectMap[lookupType][field];
        if (!selectionLevel[field]) selectionLevel[field] = {};
        if (Object.keys(subSelection).length > 0 && typeof lookupField === "string") {
          this.doSelect(subSelection, selectionLevel[field] as Partial<FieldSelectorTypeFormat>, lookupField);
        }
      }
    }
  }

  /**
   * Deselect fields that were returned.
   */
  public deselect(fields: Partial<FieldSelectorType>): this {
    this.doDeselect(fields, this.selectedFields);

    return this;
  }

  protected doDeselect(
    fields: Partial<FieldSelectorType>,
    selectionLevel: Partial<FieldSelectorTypeFormat>,
    subLevel: string = "root"
  ) {
    for (let [field, subSelection] of Object.entries(fields)) {
      if (field === "_all") {
        delete selectionLevel[subLevel];
      } else {
        if (subSelection === undefined) continue;

        let selectionSubLevel = selectionLevel[subLevel] as Partial<FieldSelectorTypeFormat>;
        if (Object.keys(subSelection).length > 0) {
          this.doDeselect(subSelection, selectionSubLevel, field);
          if (Object.keys(selectionSubLevel).length < 1) {
            delete selectionSubLevel[field];
          }
        } else {
          delete selectionSubLevel[field];
        }
      }
    }
  }

  public toReturnString(): string {
    return `{ ${this.toReturnStringPart(this.selectedFields.root)} }`;
  }

  protected toReturnStringPart(part: Partial<FieldSelectorTypeFormat>) {
    let toReturn: string[] = [];

    for (let [field, subSelection] of Object.entries(part)) {
      if (!subSelection) continue;

      toReturn.push(field);
      if (Object.keys(subSelection).length > 0) {
        toReturn.push(`{ ${this.toReturnStringPart(subSelection)} }`);
      }
    }

    return toReturn.join(" ");
  }
}

export abstract class GraphtonQueryHasArguments<ArgumentType> {
  protected queryArgs!: ArgumentType;

  /**
   * Set the arguments for this query
   */
  public setArgs(queryArgs: ArgumentType): this {
    this.queryArgs = queryArgs;

    return this;
  }

  protected toArgString(): string {
    const queryArgItems: string[] = [];
    for (const [argKey, argValue] of Object.entries(this.queryArgs)) {
      try {
        queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
      } catch (e) {
        console.warn(e);
      }
    }

    if (queryArgItems.length > 0) {
      return `(${queryArgItems.join(", ")})`;
    }

    return "";
  }

  protected argify(argValue: unknown): string {
    if (argValue instanceof GraphtonBaseEnum) {
      return `${argValue}`;
    }
    if (Array.isArray(argValue)) {
      return `[${argValue.map((v) => this.argify(v))}]`;
    }
    if (typeof argValue === "object" && !Array.isArray(argValue) && argValue !== null) {
      const decoded: string[] = [];
      for (const [key, value] of Object.entries(argValue)) {
        decoded.push(`${key}: ${this.argify(value)}`);
      }
      return `{${decoded.join(",")}}`;
    }
    if (
      typeof argValue === "string" ||
      typeof argValue === "number" ||
      typeof argValue === "boolean" ||
      argValue === null
    ) {
      return JSON.stringify(argValue);
    }

    throw new Error(`Unsure how to argify ${argValue} (of type ${typeof argValue}).`);
  }
}

abstract class GraphtonBaseEnum {
  protected constructor(public readonly value: string) {}

  valueOf() {
    return this.value;
  }

  toString() {
    return this.valueOf();
  }
}

export interface GraphtonQueryBuilder {
  queryName: string;
  rootType: RootType;
}

export interface GraphtonQuery<T> extends GraphtonQueryBuilder {
  get(requestConfig?: AxiosRequestConfig): Promise<T>;
}

export interface GraphtonMutation<T> extends GraphtonQueryBuilder {
  do(requestConfig?: AxiosRequestConfig): Promise<T>;
}

export interface GraphtonSubscription<T> extends GraphtonQueryBuilder {
  subscribe(requestConfig?: AxiosRequestConfig): Promise<T>;
}

// REGION: Types
export type Date = any;
export type Time = number;
export type ID = string;
export type String = string;
export type Int = number;
export type Boolean = boolean;
export type User = {
  id: ID;
  username: String;
  age: Int | null;
  role: RoleEnumString;
  posts: Post[];
  friends: User[];
};
export type Post = {
  id: ID;
  author: User;
  text: String;
  posted_at_date: Date;
  posted_at_time: Time;
  relatedPosts: Post[];
};
const fieldObjectMap: Record<string, Record<string, string | null>> = {
  User: { id: null, username: null, age: null, role: null, posts: "Post", friends: "User" },
  Post: { id: null, author: "User", text: null, posted_at_date: null, posted_at_time: null, relatedPosts: "Post" },
};
export type UserOrderInput = {
  column: UserSortColumn;
  order: SortOrder;
};
export type RoleEnumString = "ADMIN" | "USER" | "GUEST";

export class Role extends GraphtonBaseEnum {
  static readonly ADMIN: Role = new Role("ADMIN");
  static readonly USER: Role = new Role("USER");
  static readonly GUEST: Role = new Role("GUEST");
  static readonly possibleValues = { ADMIN: Role.ADMIN, USER: Role.USER, GUEST: Role.GUEST };

  private constructor(value: keyof typeof Role.possibleValues) {
    super(value);
  }

  public static parse(value: keyof typeof Role.possibleValues): Role {
    return Role.possibleValues[value];
  }

  public static list(): Role[] {
    return Object.values(Role.possibleValues);
  }
}

export type SortOrderEnumString = "ASC" | "DESC";

export class SortOrder extends GraphtonBaseEnum {
  static readonly ASC: SortOrder = new SortOrder("ASC");
  static readonly DESC: SortOrder = new SortOrder("DESC");
  static readonly possibleValues = { ASC: SortOrder.ASC, DESC: SortOrder.DESC };

  private constructor(value: keyof typeof SortOrder.possibleValues) {
    super(value);
  }

  public static parse(value: keyof typeof SortOrder.possibleValues): SortOrder {
    return SortOrder.possibleValues[value];
  }

  public static list(): SortOrder[] {
    return Object.values(SortOrder.possibleValues);
  }
}

export type UserSortColumnEnumString = "id" | "username" | "age";

export class UserSortColumn extends GraphtonBaseEnum {
  static readonly id: UserSortColumn = new UserSortColumn("id");
  static readonly username: UserSortColumn = new UserSortColumn("username");
  static readonly age: UserSortColumn = new UserSortColumn("age");
  static readonly possibleValues = {
    id: UserSortColumn.id,
    username: UserSortColumn.username,
    age: UserSortColumn.age,
  };

  private constructor(value: keyof typeof UserSortColumn.possibleValues) {
    super(value);
  }

  public static parse(value: keyof typeof UserSortColumn.possibleValues): UserSortColumn {
    return UserSortColumn.possibleValues[value];
  }

  public static list(): UserSortColumn[] {
    return Object.values(UserSortColumn.possibleValues);
  }
}

export type UserFieldSelector = {
  _all?: {};
  id?: {};
  username?: {};
  age?: {};
  role?: {};
  posts?: PostFieldSelector;
  friends?: UserFieldSelector;
};
export type PostFieldSelector = {
  _all?: {};
  id?: {};
  author?: UserFieldSelector;
  text?: {};
  posted_at_date?: {};
  posted_at_time?: {};
  relatedPosts?: PostFieldSelector;
};

// REGION: Queries
export class Query {
  public static users() {
    return new UsersQuery();
  }
  public static usersOrdered(queryArgs: UsersOrderedQueryArguments) {
    return new UsersOrderedQuery().setArgs(queryArgs);
  }
  public static user(queryArgs: UserQueryArguments) {
    return new UserQuery().setArgs(queryArgs);
  }
  public static userExists(queryArgs: UserExistsQueryArguments) {
    return new UserExistsQuery().setArgs(queryArgs);
  }
  public static healthCheck() {
    return new HealthCheckQuery();
  }
}

export interface UsersQueryResponse {
  data: {
    users: User[];
  };
}

class UsersQuery
  extends GraphtonBaseQuery<UsersQueryResponse>
  implements GraphtonQuery<UsersQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "users";
  public readonly rootType = "query";
  protected readonly returnType = "User";

  /**
   * Execute the query and get the results
   */
  async get(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<UsersQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

interface UsersQuery
  extends GraphtonBaseQuery<UsersQueryResponse>,
    GraphtonQueryReturnsObject<UserFieldSelector, User> {
  initGraphtonQueryReturnsObject(): void;
  toReturnString(): string;
}
applyMixins(UsersQuery, [GraphtonBaseQuery, GraphtonQueryReturnsObject]);

export interface UsersOrderedQueryResponse {
  data: {
    usersOrdered: User[];
  };
}

export interface UsersOrderedQueryArguments {
  orderBy?: UserOrderInput[];
}

class UsersOrderedQuery
  extends GraphtonBaseQuery<UsersOrderedQueryResponse>
  implements GraphtonQuery<UsersOrderedQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "usersOrdered";
  public readonly rootType = "query";
  protected readonly returnType = "User";

  /**
   * Execute the query and get the results
   */
  async get(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<UsersOrderedQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

interface UsersOrderedQuery
  extends GraphtonBaseQuery<UsersOrderedQueryResponse>,
    GraphtonQueryHasArguments<UsersOrderedQueryArguments>,
    GraphtonQueryReturnsObject<UserFieldSelector, User> {
  initGraphtonQueryReturnsObject(): void;
  toReturnString(): string;
  toArgString(): string;
}
applyMixins(UsersOrderedQuery, [GraphtonBaseQuery, GraphtonQueryHasArguments, GraphtonQueryReturnsObject]);

export interface UserQueryResponse {
  data: {
    user: User | null;
  };
}

export interface UserQueryArguments {
  id: ID;
}

class UserQuery
  extends GraphtonBaseQuery<UserQueryResponse>
  implements GraphtonQuery<UserQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "user";
  public readonly rootType = "query";
  protected readonly returnType = "User";

  /**
   * Execute the query and get the results
   */
  async get(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<UserQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

interface UserQuery
  extends GraphtonBaseQuery<UserQueryResponse>,
    GraphtonQueryHasArguments<UserQueryArguments>,
    GraphtonQueryReturnsObject<UserFieldSelector, User> {
  initGraphtonQueryReturnsObject(): void;
  toReturnString(): string;
  toArgString(): string;
}
applyMixins(UserQuery, [GraphtonBaseQuery, GraphtonQueryHasArguments, GraphtonQueryReturnsObject]);

export interface UserExistsQueryResponse {
  data: {
    userExists: Boolean;
  };
}

export interface UserExistsQueryArguments {
  id: ID;
}

class UserExistsQuery
  extends GraphtonBaseQuery<UserExistsQueryResponse>
  implements GraphtonQuery<UserExistsQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "userExists";
  public readonly rootType = "query";

  /**
   * Execute the query and get the results
   */
  async get(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<UserExistsQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

interface UserExistsQuery
  extends GraphtonBaseQuery<UserExistsQueryResponse>,
    GraphtonQueryHasArguments<UserExistsQueryArguments> {
  toArgString(): string;
}
applyMixins(UserExistsQuery, [GraphtonBaseQuery, GraphtonQueryHasArguments]);

export interface HealthCheckQueryResponse {
  data: {
    healthCheck: Boolean;
  };
}

class HealthCheckQuery
  extends GraphtonBaseQuery<HealthCheckQueryResponse>
  implements GraphtonQuery<HealthCheckQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "healthCheck";
  public readonly rootType = "query";

  /**
   * Execute the query and get the results
   */
  async get(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<HealthCheckQueryResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

// REGION: Mutations
export class Mutation {
  public static createUser(queryArgs: CreateUserMutationArguments) {
    return new CreateUserMutation().setArgs(queryArgs);
  }
  public static updateUser(queryArgs: UpdateUserMutationArguments) {
    return new UpdateUserMutation().setArgs(queryArgs);
  }
  public static deleteUser(queryArgs: DeleteUserMutationArguments) {
    return new DeleteUserMutation().setArgs(queryArgs);
  }
}

export interface CreateUserMutationResponse {
  data: {
    createUser: User;
  };
}

export interface CreateUserMutationArguments {
  username: String;
  role: Role;
  age?: Int;
}

class CreateUserMutation
  extends GraphtonBaseQuery<CreateUserMutationResponse>
  implements GraphtonMutation<CreateUserMutationResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "createUser";
  public readonly rootType = "mutation";
  protected readonly returnType = "User";

  /**
   * Execute the query and get the results
   */
  async do(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<CreateUserMutationResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

interface CreateUserMutation
  extends GraphtonBaseQuery<CreateUserMutationResponse>,
    GraphtonQueryHasArguments<CreateUserMutationArguments>,
    GraphtonQueryReturnsObject<UserFieldSelector, User> {
  initGraphtonQueryReturnsObject(): void;
  toReturnString(): string;
  toArgString(): string;
}
applyMixins(CreateUserMutation, [GraphtonBaseQuery, GraphtonQueryHasArguments, GraphtonQueryReturnsObject]);

export interface UpdateUserMutationResponse {
  data: {
    updateUser: User;
  };
}

export interface UpdateUserMutationArguments {
  id: ID;
  username?: String;
  role?: Role;
  age?: Int;
}

class UpdateUserMutation
  extends GraphtonBaseQuery<UpdateUserMutationResponse>
  implements GraphtonMutation<UpdateUserMutationResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "updateUser";
  public readonly rootType = "mutation";
  protected readonly returnType = "User";

  /**
   * Execute the query and get the results
   */
  async do(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<UpdateUserMutationResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

interface UpdateUserMutation
  extends GraphtonBaseQuery<UpdateUserMutationResponse>,
    GraphtonQueryHasArguments<UpdateUserMutationArguments>,
    GraphtonQueryReturnsObject<UserFieldSelector, User> {
  initGraphtonQueryReturnsObject(): void;
  toReturnString(): string;
  toArgString(): string;
}
applyMixins(UpdateUserMutation, [GraphtonBaseQuery, GraphtonQueryHasArguments, GraphtonQueryReturnsObject]);

export interface DeleteUserMutationResponse {
  data: {
    deleteUser: User;
  };
}

export interface DeleteUserMutationArguments {
  id: ID;
}

class DeleteUserMutation
  extends GraphtonBaseQuery<DeleteUserMutationResponse>
  implements GraphtonMutation<DeleteUserMutationResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "deleteUser";
  public readonly rootType = "mutation";
  protected readonly returnType = "User";

  /**
   * Execute the query and get the results
   */
  async do(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<DeleteUserMutationResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

interface DeleteUserMutation
  extends GraphtonBaseQuery<DeleteUserMutationResponse>,
    GraphtonQueryHasArguments<DeleteUserMutationArguments>,
    GraphtonQueryReturnsObject<UserFieldSelector, User> {
  initGraphtonQueryReturnsObject(): void;
  toReturnString(): string;
  toArgString(): string;
}
applyMixins(DeleteUserMutation, [GraphtonBaseQuery, GraphtonQueryHasArguments, GraphtonQueryReturnsObject]);

// REGION: Subscriptions
export class Subscription {
  public static postAdded() {
    return new PostAddedSubscription();
  }
}

export interface PostAddedSubscriptionResponse {
  data: {
    postAdded: Post;
  };
}

class PostAddedSubscription
  extends GraphtonBaseQuery<PostAddedSubscriptionResponse>
  implements GraphtonSubscription<PostAddedSubscriptionResponse & { [p: string]: any; axiosResponse: AxiosResponse }>
{
  public readonly queryName = "postAdded";
  public readonly rootType = "subscription";
  protected readonly returnType = "Post";

  /**
   * Execute the query and get the results
   */
  async subscribe(
    requestConfig: AxiosRequestConfig = {}
  ): Promise<PostAddedSubscriptionResponse & { [p: string]: any; axiosResponse: AxiosResponse }> {
    return await super.execute(requestConfig);
  }
}

interface PostAddedSubscription
  extends GraphtonBaseQuery<PostAddedSubscriptionResponse>,
    GraphtonQueryReturnsObject<PostFieldSelector, Post> {
  initGraphtonQueryReturnsObject(): void;
  toReturnString(): string;
}
applyMixins(PostAddedSubscription, [GraphtonBaseQuery, GraphtonQueryReturnsObject]);
