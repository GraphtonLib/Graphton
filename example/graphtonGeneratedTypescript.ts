/**
 * FILE GENERATED BY GRAPHTON
 * DO NOT EDIT - CHANGES WILL BE OVERWRITTEN
 * @see https://github.com/GraphtonLib/Graphton
 **/

// REGION: Base classes
const settings = {
    defaultHeaders: {},
    defaultUrl: ''
}

export class GraphtonSettings {
    public static setDefaultHeaders(headers: Record<string, string>): void {
        settings.defaultHeaders = headers;
    }

    public static setDefaultUrl(defaultUrl: string): void {
        settings.defaultUrl = defaultUrl;
    }
}

import axios, {AxiosResponse} from 'axios';

type GraphQLServerEndpoint = string;
type Headers = Record<string, string>;

interface RequestOptions {
    headers?: Headers,
    url?: GraphQLServerEndpoint
}
interface QueryResponse {
    data: Record<string, unknown>,
    response: AxiosResponse
}

 class GraphtonEnum<T extends string> {
    public readonly enumValue: T;
    constructor(enumValue: T) {
        this.enumValue = enumValue;
    }
}

 type RootType = 'query'|'mutation';

 abstract class GraphtonBaseQuery<T> {
    protected abstract queryName: string;
    protected abstract rootType: RootType;
    protected abstract returnType: GraphtonBaseReturnTypeBuilder<any, any> | null;

    public abstract setArgs(queryArgs: Partial<T>): void;
    protected abstract toArgString(): string;

    /**
     * Transform builder to graphql query string
     */
    public toQuery(): string {
        return `${this.rootType} ${this.queryName} { ${this.queryName}${this.toArgString()} ${this.returnType?.toReturnTypeString()||''} }`;
    }

    protected argify(argValue: unknown): string {
        if(argValue instanceof GraphtonEnum) {
            return `${argValue.enumValue}`;
        }
        if(Array.isArray(argValue)) {
            return `[${argValue.map(v=>this.argify(v))}]`;
        }
        if(typeof argValue === 'object' && !Array.isArray(argValue) && argValue !== null) {
            const decoded: string[] = [];
            for(const [key, value] of Object.entries(argValue)) {
                decoded.push(`${key}: ${this.argify(value)}`);
            }
            return `{${decoded.join(',')}}`;
        }
        if(typeof argValue === 'string' || typeof argValue === 'number' || typeof argValue === 'boolean' || argValue === null) {
            return JSON.stringify(argValue);
        }

        console.warn(`Unsure how to argify ${argValue} (of type ${typeof argValue}).`);
        return '';
    }

    /**
     * Execute the query
     */
    protected async execute(requestOptions: RequestOptions = {}): Promise<QueryResponse> {
        const response = await axios.post(requestOptions?.url || settings.defaultUrl, {query: this.toQuery()}, {
            headers: {
                'Content-Type': 'application/json',
                ...settings.defaultHeaders,
                ...requestOptions?.headers
            },
        });

        return {
            data: response.data.data,
            response
        }
    }
}

type AvailableFieldBuilderConstructor<T> = {
    [Property in keyof T]: new() => T[Property]
}
type QueryObjectFields<T> = {
    [Property in keyof T]?: T[Property]
}

abstract class GraphtonBaseReturnTypeBuilder<ObjectField extends Record<keyof ObjectField, GraphtonBaseReturnTypeBuilder<any,any>>, SimpleField> {
    protected abstract availableSimpleFields: Set<SimpleField>;
    protected querySimpleFields: Set<SimpleField> = new Set([]);
    protected queryObjectFields: QueryObjectFields<ObjectField> = {};
    protected abstract queryObjectFieldBuilders: AvailableFieldBuilderConstructor<ObjectField>;
    protected abstract typeName: string;

    /**
     * Select all known fields te be returned
     */
    public all(): this {
        this.querySimpleFields = new Set(this.availableSimpleFields);
        return this;
    }

    /**
     * Clear all selected fields.
     */
    public clear(): this {
        this.querySimpleFields.clear();
        return this;
    }

    /**
     * Select `...fieldNames` to be returned
     */
    public with(...fieldNames: SimpleField[]): this {
        for(const fieldName of fieldNames) {
            if(!this.availableSimpleFields.has(fieldName)) {
                console.warn(`Field "${fieldName}" might not exist in type "${this.typeName}"!`);
            }

            this.querySimpleFields.add(fieldName);
        }

        return this;
    }

    /**
     * Remove `...fieldNames` from selection
     */
    public without(...fieldNames: SimpleField[]): this {
        for(const fieldName of fieldNames) {
            this.querySimpleFields.delete(fieldName);
        }

        return this;
    }

    /**
     * Alias for .all().without(...fieldNames)
     */
    public except(...fieldNames: SimpleField[]): this {
        return this.all().without(...fieldNames);
    }

    /**
     * Alias for .clear().with(...fieldNames)
     */
    public only(...fieldNames: SimpleField[]): this {
        return this.clear().with(...fieldNames);
    }

    /**
     * Add the `relatedType` OBJECT field, selecting the fields for that type using the `buildFields` closure
     */
    public withRelated<ObjectFieldName extends keyof ObjectField>(relatedType: ObjectFieldName, buildFields: (r: ObjectField[ObjectFieldName]) => void): this {
        const relatedReturnType = new this.queryObjectFieldBuilders[relatedType]();
        buildFields(relatedReturnType);
        this.queryObjectFields[relatedType] = relatedReturnType;

        return this;
    }

    /**
     * Remove the `relatedType` OBJECT field
     * Selected fields for `relatedType` will be removed!
     */
    public withoutRelated<ObjectFieldName extends keyof ObjectField>(relatedType: ObjectFieldName): this {
        delete this.queryObjectFields[relatedType];

        return this;
    }

    /**
     * Compile the selected fields to a GraphQL selection.
     */
    public toReturnTypeString(): string {
        if(this.querySimpleFields.size < 1 && Object.values(this.queryObjectFields).length < 1) {
            return '';
        }

        const returnTypeString = ['{', ...this.querySimpleFields];

        for(const [objectType, objectField] of Object.entries(this.queryObjectFields)) {
            const objectFieldReturnTypeString = (<GraphtonBaseReturnTypeBuilder<any,any>>objectField).toReturnTypeString();
            if(objectFieldReturnTypeString.length > 0) {
                returnTypeString.push(objectType, objectFieldReturnTypeString);
            }
        }

        returnTypeString.push('}');

        return returnTypeString.join(' ');
    }
}

// REGION: Types
export interface User {
  id?: number,
  name?: string,
  age?: (number | null),
  role?: Role,
  posts?: Post[],
  friends?: User[],
}
export interface Post {
  id?: number,
  author?: User,
  text?: string,
  relatedPosts?: Post[],
}
export interface UserInput {
  column?: string,
  order?: SortOrder,
}
export type Role = GraphtonEnum<'ADMIN'>|GraphtonEnum<'USER'>|GraphtonEnum<'GUEST'>;
export const Role = {
  ADMIN: new GraphtonEnum('ADMIN'),
  USER: new GraphtonEnum('USER'),
  GUEST: new GraphtonEnum('GUEST')
}
export type SortOrder = GraphtonEnum<'ASC'>|GraphtonEnum<'DESC'>;
export const SortOrder = {
  ASC: new GraphtonEnum('ASC'),
  DESC: new GraphtonEnum('DESC')
}

interface UserReturnTypeBuilderObjectBuilder {'posts':PostReturnTypeBuilder,'friends':UserReturnTypeBuilder}
type UserReturnTypeSimpleField = 'id'|'name'|'age'|'role';

class UserReturnTypeBuilder extends GraphtonBaseReturnTypeBuilder<UserReturnTypeBuilderObjectBuilder, UserReturnTypeSimpleField> {
    protected availableSimpleFields: Set<UserReturnTypeSimpleField> = new Set(['id','name','age','role']);
    protected typeName = 'User';
    protected queryObjectFieldBuilders = {'posts':PostReturnTypeBuilder,'friends':UserReturnTypeBuilder};
}

interface PostReturnTypeBuilderObjectBuilder {'author':UserReturnTypeBuilder,'relatedPosts':PostReturnTypeBuilder}
type PostReturnTypeSimpleField = 'id'|'text';

class PostReturnTypeBuilder extends GraphtonBaseReturnTypeBuilder<PostReturnTypeBuilderObjectBuilder, PostReturnTypeSimpleField> {
    protected availableSimpleFields: Set<PostReturnTypeSimpleField> = new Set(['id','text']);
    protected typeName = 'Post';
    protected queryObjectFieldBuilders = {'author':UserReturnTypeBuilder,'relatedPosts':PostReturnTypeBuilder};
}

// REGION: Queries
export class Query {
  public static users() {
    return new UsersQuery();
  }
  public static usersOrdered(queryArgs?: UsersOrderedQueryArguments) {
    return new UsersOrderedQuery(queryArgs);
  }
  public static user(queryArgs?: UserQueryArguments) {
    return new UserQuery(queryArgs);
  }
  public static userExists(queryArgs?: UserExistsQueryArguments) {
    return new UserExistsQuery(queryArgs);
  }
}

interface UsersQueryResponse {
    data: {
        users: User[]
    };
    response: AxiosResponse;
}

class UsersQuery extends GraphtonBaseQuery<Record<string, never>> {
    protected queryName = 'users';
    protected queryArgs: Partial<Record<string, never>> = {};
    protected rootType: RootType = 'query';
    protected returnType = new UserReturnTypeBuilder();

    public setArgs(queryArgs: Partial<Record<string, never>>) {
        this.queryArgs = {...this.queryArgs, ...queryArgs};
    }

    protected toArgString(): string {
        const queryArgItems: string[] = [];
        for(const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }

        if(queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }

        return '';
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void): this {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions: RequestOptions = {}): Promise<UsersQueryResponse> {
        return <UsersQueryResponse>(await super.execute(requestOptions));
    }

}

interface UsersOrderedQueryResponse {
    data: {
        usersOrdered: User[]
    };
    response: AxiosResponse;
}

interface UsersOrderedQueryArguments {
    orderBy?: (UserInput | null)[];
}

class UsersOrderedQuery extends GraphtonBaseQuery<UsersOrderedQueryArguments> {
    protected queryName = 'usersOrdered';
    protected queryArgs: Partial<UsersOrderedQueryArguments> = {};
    protected rootType: RootType = 'query';
    protected returnType = new UserReturnTypeBuilder();

    constructor(queryArgs?: UsersOrderedQueryArguments) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }

    public setArgs(queryArgs: Partial<UsersOrderedQueryArguments>) {
        this.queryArgs = {...this.queryArgs, ...queryArgs};
    }

    protected toArgString(): string {
        const queryArgItems: string[] = [];
        for(const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }

        if(queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }

        return '';
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void): this {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions: RequestOptions = {}): Promise<UsersOrderedQueryResponse> {
        return <UsersOrderedQueryResponse>(await super.execute(requestOptions));
    }

}

interface UserQueryResponse {
    data: {
        user?: (User | null)
    };
    response: AxiosResponse;
}

interface UserQueryArguments {
    id: number;
}

class UserQuery extends GraphtonBaseQuery<UserQueryArguments> {
    protected queryName = 'user';
    protected queryArgs: Partial<UserQueryArguments> = {};
    protected rootType: RootType = 'query';
    protected returnType = new UserReturnTypeBuilder();

    constructor(queryArgs?: UserQueryArguments) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }

    public setArgs(queryArgs: Partial<UserQueryArguments>) {
        this.queryArgs = {...this.queryArgs, ...queryArgs};
    }

    protected toArgString(): string {
        const queryArgItems: string[] = [];
        for(const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }

        if(queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }

        return '';
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void): this {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions: RequestOptions = {}): Promise<UserQueryResponse> {
        return <UserQueryResponse>(await super.execute(requestOptions));
    }

}

interface UserExistsQueryResponse {
    data: {
        userExists: boolean
    };
    response: AxiosResponse;
}

interface UserExistsQueryArguments {
    id: number;
}

class UserExistsQuery extends GraphtonBaseQuery<UserExistsQueryArguments> {
    protected queryName = 'userExists';
    protected queryArgs: Partial<UserExistsQueryArguments> = {};
    protected rootType: RootType = 'query';
    protected returnType =  null;

    constructor(queryArgs?: UserExistsQueryArguments) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }

    public setArgs(queryArgs: Partial<UserExistsQueryArguments>) {
        this.queryArgs = {...this.queryArgs, ...queryArgs};
    }

    protected toArgString(): string {
        const queryArgItems: string[] = [];
        for(const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }

        if(queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }

        return '';
    }

    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions: RequestOptions = {}): Promise<UserExistsQueryResponse> {
        return <UserExistsQueryResponse>(await super.execute(requestOptions));
    }

}

// REGION: Mutations
export class Mutation {
  public static createUser(queryArgs?: CreateUserMutationArguments) {
    return new CreateUserMutation(queryArgs);
  }
  public static updateUser(queryArgs?: UpdateUserMutationArguments) {
    return new UpdateUserMutation(queryArgs);
  }
  public static deleteUser(queryArgs?: DeleteUserMutationArguments) {
    return new DeleteUserMutation(queryArgs);
  }
}

interface CreateUserMutationResponse {
    data: {
        createUser: User
    };
    response: AxiosResponse;
}

interface CreateUserMutationArguments {
    name: string;
    age?: (number | null);
}

class CreateUserMutation extends GraphtonBaseQuery<CreateUserMutationArguments> {
    protected queryName = 'createUser';
    protected queryArgs: Partial<CreateUserMutationArguments> = {};
    protected rootType: RootType = 'mutation';
    protected returnType = new UserReturnTypeBuilder();

    constructor(queryArgs?: CreateUserMutationArguments) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }

    public setArgs(queryArgs: Partial<CreateUserMutationArguments>) {
        this.queryArgs = {...this.queryArgs, ...queryArgs};
    }

    protected toArgString(): string {
        const queryArgItems: string[] = [];
        for(const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }

        if(queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }

        return '';
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void): this {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions: RequestOptions = {}): Promise<CreateUserMutationResponse> {
        return <CreateUserMutationResponse>(await super.execute(requestOptions));
    }

}

interface UpdateUserMutationResponse {
    data: {
        updateUser: User
    };
    response: AxiosResponse;
}

interface UpdateUserMutationArguments {
    id: number;
    name?: (string | null);
    age?: (number | null);
}

class UpdateUserMutation extends GraphtonBaseQuery<UpdateUserMutationArguments> {
    protected queryName = 'updateUser';
    protected queryArgs: Partial<UpdateUserMutationArguments> = {};
    protected rootType: RootType = 'mutation';
    protected returnType = new UserReturnTypeBuilder();

    constructor(queryArgs?: UpdateUserMutationArguments) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }

    public setArgs(queryArgs: Partial<UpdateUserMutationArguments>) {
        this.queryArgs = {...this.queryArgs, ...queryArgs};
    }

    protected toArgString(): string {
        const queryArgItems: string[] = [];
        for(const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }

        if(queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }

        return '';
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void): this {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions: RequestOptions = {}): Promise<UpdateUserMutationResponse> {
        return <UpdateUserMutationResponse>(await super.execute(requestOptions));
    }

}

interface DeleteUserMutationResponse {
    data: {
        deleteUser: User
    };
    response: AxiosResponse;
}

interface DeleteUserMutationArguments {
    id: number;
}

class DeleteUserMutation extends GraphtonBaseQuery<DeleteUserMutationArguments> {
    protected queryName = 'deleteUser';
    protected queryArgs: Partial<DeleteUserMutationArguments> = {};
    protected rootType: RootType = 'mutation';
    protected returnType = new UserReturnTypeBuilder();

    constructor(queryArgs?: DeleteUserMutationArguments) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }

    public setArgs(queryArgs: Partial<DeleteUserMutationArguments>) {
        this.queryArgs = {...this.queryArgs, ...queryArgs};
    }

    protected toArgString(): string {
        const queryArgItems: string[] = [];
        for(const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }

        if(queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }

        return '';
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void): this {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions: RequestOptions = {}): Promise<DeleteUserMutationResponse> {
        return <DeleteUserMutationResponse>(await super.execute(requestOptions));
    }

}
