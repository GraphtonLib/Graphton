/**
 * FILE GENERATED BY GRAPHTON
 * DO NOT EDIT - CHANGES WILL BE OVERWRITTEN
 * @see https://github.com/GraphtonLib/Graphton
 **/
// REGION: Base classes
const settings = {
    defaultHeaders: {},
    defaultUrl: ''
};
export class GraphtonSettings {
    static setDefaultHeaders(headers) {
        settings.defaultHeaders = headers;
    }
    static setDefaultUrl(defaultUrl) {
        settings.defaultUrl = defaultUrl;
    }
}
import axios from 'axios';
class GraphtonEnum {
    enumValue;
    constructor(enumValue) {
        this.enumValue = enumValue;
    }
}
class GraphtonBaseQuery {
    /**
     * Transform builder to graphql query string
     */
    toQuery() {
        return `${this.rootType} ${this.queryName} { ${this.queryName}${this.toArgString()} ${this.returnType?.toReturnTypeString() || ''} }`;
    }
    argify(argValue) {
        if (argValue instanceof GraphtonEnum) {
            return `${argValue.enumValue}`;
        }
        if (Array.isArray(argValue)) {
            return `[${argValue.map(v => this.argify(v))}]`;
        }
        if (typeof argValue === 'object' && !Array.isArray(argValue) && argValue !== null) {
            const decoded = [];
            for (const [key, value] of Object.entries(argValue)) {
                decoded.push(`${key}: ${this.argify(value)}`);
            }
            return `{${decoded.join(',')}}`;
        }
        if (typeof argValue === 'string' || typeof argValue === 'number' || typeof argValue === 'boolean' || argValue === null) {
            return JSON.stringify(argValue);
        }
        console.warn(`Unsure how to argify ${argValue} (of type ${typeof argValue}).`);
        return '';
    }
    /**
     * Execute the query
     */
    async execute(requestOptions = {}) {
        const response = await axios.post(requestOptions?.url || settings.defaultUrl, { query: this.toQuery() }, {
            headers: {
                'Content-Type': 'application/json',
                ...settings.defaultHeaders,
                ...requestOptions?.headers
            },
        });
        return {
            data: response.data.data,
            response
        };
    }
}
class GraphtonBaseReturnTypeBuilder {
    querySimpleFields = new Set([]);
    queryObjectFields = {};
    /**
     * Select all known fields te be returned
     */
    all() {
        this.querySimpleFields = new Set(this.availableSimpleFields);
        return this;
    }
    /**
     * Clear all selected fields.
     */
    clear() {
        this.querySimpleFields.clear();
        return this;
    }
    /**
     * Select `...fieldNames` to be returned
     */
    with(...fieldNames) {
        for (const fieldName of fieldNames) {
            if (!this.availableSimpleFields.has(fieldName)) {
                console.warn(`Field "${fieldName}" might not exist in type "${this.typeName}"!`);
            }
            this.querySimpleFields.add(fieldName);
        }
        return this;
    }
    /**
     * Remove `...fieldNames` from selection
     */
    without(...fieldNames) {
        for (const fieldName of fieldNames) {
            this.querySimpleFields.delete(fieldName);
        }
        return this;
    }
    /**
     * Alias for .all().without(...fieldNames)
     */
    except(...fieldNames) {
        return this.all().without(...fieldNames);
    }
    /**
     * Alias for .clear().with(...fieldNames)
     */
    only(...fieldNames) {
        return this.clear().with(...fieldNames);
    }
    /**
     * Add the `relatedType` OBJECT field, selecting the fields for that type using the `buildFields` closure
     */
    withRelated(relatedType, buildFields) {
        const relatedReturnType = new this.queryObjectFieldBuilders[relatedType]();
        buildFields(relatedReturnType);
        this.queryObjectFields[relatedType] = relatedReturnType;
        return this;
    }
    /**
     * Remove the `relatedType` OBJECT field
     * Selected fields for `relatedType` will be removed!
     */
    withoutRelated(relatedType) {
        delete this.queryObjectFields[relatedType];
        return this;
    }
    /**
     * Compile the selected fields to a GraphQL selection.
     */
    toReturnTypeString() {
        if (this.querySimpleFields.size < 1 && Object.values(this.queryObjectFields).length < 1) {
            return '';
        }
        const returnTypeString = ['{', ...this.querySimpleFields];
        for (const [objectType, objectField] of Object.entries(this.queryObjectFields)) {
            const objectFieldReturnTypeString = objectField.toReturnTypeString();
            if (objectFieldReturnTypeString.length > 0) {
                returnTypeString.push(objectType, objectFieldReturnTypeString);
            }
        }
        returnTypeString.push('}');
        return returnTypeString.join(' ');
    }
}
export const Role = {
    ADMIN: new GraphtonEnum("ADMIN"),
    USER: new GraphtonEnum("USER"),
    GUEST: new GraphtonEnum("GUEST")
};
export const SortOrder = {
    ASC: new GraphtonEnum("ASC"),
    DESC: new GraphtonEnum("DESC")
};
class UserReturnTypeBuilder extends GraphtonBaseReturnTypeBuilder {
    availableSimpleFields = new Set(["id", "name", "age", "role"]);
    typeName = 'User';
    queryObjectFieldBuilders = { "posts": PostReturnTypeBuilder, "friends": UserReturnTypeBuilder };
}
class PostReturnTypeBuilder extends GraphtonBaseReturnTypeBuilder {
    availableSimpleFields = new Set(["id", "text"]);
    typeName = 'Post';
    queryObjectFieldBuilders = { "author": UserReturnTypeBuilder, "relatedPosts": PostReturnTypeBuilder };
}
// REGION: Queries
export class Query {
    static users() {
        return new UsersQuery();
    }
    static usersOrdered(queryArgs) {
        return new UsersOrderedQuery(queryArgs);
    }
    static user(queryArgs) {
        return new UserQuery(queryArgs);
    }
    static userExists(queryArgs) {
        return new UserExistsQuery(queryArgs);
    }
}
class UsersQuery extends GraphtonBaseQuery {
    queryName = 'users';
    queryArgs = {};
    rootType = 'query';
    returnType = new UserReturnTypeBuilder();
    setArgs(queryArgs) {
        this.queryArgs = { ...this.queryArgs, ...queryArgs };
    }
    toArgString() {
        const queryArgItems = [];
        for (const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }
        if (queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }
        return '';
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class UsersOrderedQuery extends GraphtonBaseQuery {
    queryName = 'usersOrdered';
    queryArgs = {};
    rootType = 'query';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    setArgs(queryArgs) {
        this.queryArgs = { ...this.queryArgs, ...queryArgs };
    }
    toArgString() {
        const queryArgItems = [];
        for (const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }
        if (queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }
        return '';
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class UserQuery extends GraphtonBaseQuery {
    queryName = 'user';
    queryArgs = {};
    rootType = 'query';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    setArgs(queryArgs) {
        this.queryArgs = { ...this.queryArgs, ...queryArgs };
    }
    toArgString() {
        const queryArgItems = [];
        for (const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }
        if (queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }
        return '';
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class UserExistsQuery extends GraphtonBaseQuery {
    queryName = 'userExists';
    queryArgs = {};
    rootType = 'query';
    returnType = null;
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    setArgs(queryArgs) {
        this.queryArgs = { ...this.queryArgs, ...queryArgs };
    }
    toArgString() {
        const queryArgItems = [];
        for (const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }
        if (queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }
        return '';
    }
    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
// REGION: Mutations
export class Mutation {
    static createUser(queryArgs) {
        return new CreateUserMutation(queryArgs);
    }
    static updateUser(queryArgs) {
        return new UpdateUserMutation(queryArgs);
    }
    static deleteUser(queryArgs) {
        return new DeleteUserMutation(queryArgs);
    }
}
class CreateUserMutation extends GraphtonBaseQuery {
    queryName = 'createUser';
    queryArgs = {};
    rootType = 'mutation';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    setArgs(queryArgs) {
        this.queryArgs = { ...this.queryArgs, ...queryArgs };
    }
    toArgString() {
        const queryArgItems = [];
        for (const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }
        if (queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }
        return '';
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class UpdateUserMutation extends GraphtonBaseQuery {
    queryName = 'updateUser';
    queryArgs = {};
    rootType = 'mutation';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    setArgs(queryArgs) {
        this.queryArgs = { ...this.queryArgs, ...queryArgs };
    }
    toArgString() {
        const queryArgItems = [];
        for (const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }
        if (queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }
        return '';
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class DeleteUserMutation extends GraphtonBaseQuery {
    queryName = 'deleteUser';
    queryArgs = {};
    rootType = 'mutation';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    setArgs(queryArgs) {
        this.queryArgs = { ...this.queryArgs, ...queryArgs };
    }
    toArgString() {
        const queryArgItems = [];
        for (const [argKey, argValue] of Object.entries(this.queryArgs)) {
            if (argValue) {
                queryArgItems.push(`${argKey}: ${this.argify(argValue)}`);
            }
        }
        if (queryArgItems.length > 0) {
            return `(${queryArgItems.join(', ')})`;
        }
        return '';
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
