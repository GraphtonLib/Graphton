/**
 * FILE GENERATED BY GRAPHTON
 * DO NOT EDIT - CHANGES WILL BE OVERWRITTEN
 * @see https://github.com/GraphtonLib/Graphton
 **/
// REGION: Base classes
const settings = {
    defaultHeaders: {},
    defaultUrl: ''
};
export class GraphtonSettings {
    static setDefaultHeaders(headers) {
        settings.defaultHeaders = headers;
    }
    static setDefaultUrl(defaultUrl) {
        settings.defaultUrl = defaultUrl;
    }
}
import axios from 'axios';
class GraphtonBaseQuery {
    queryArgs = {};
    setArgs(queryArgs) {
        const newArgs = {};
        const mergedArgs = { ...this.queryArgs, ...queryArgs };
        for (const key in mergedArgs) {
            if (this.queryArgs[key] !== undefined && this.queryArgs[key] !== null) {
                newArgs[key] = this.queryArgs[key];
            }
        }
    }
    /**
     * Transform builder to graphql query string
     */
    toQuery() {
        const queryArgs = Object.entries(this.queryArgs);
        let queryArgString = '';
        if (queryArgs.length > 0) {
            const queryArgItems = [];
            for (const [name, value] of queryArgs) {
                queryArgItems.push(`${name}: ${JSON.stringify(value)}`);
            }
            queryArgString = `(${queryArgItems.join(', ')})`;
        }
        return `${this.rootType} ${this.queryName} { ${this.queryName}${queryArgString} ${this.returnType?.toReturnTypeString() || ''} }`;
    }
    /**
     * Execute the query
     */
    async execute(requestOptions = {}) {
        const response = await axios.post(requestOptions?.url || settings.defaultUrl, { query: this.toQuery() }, {
            headers: {
                'Content-Type': 'application/json',
                ...settings.defaultHeaders,
                ...requestOptions?.headers
            },
        });
        return {
            data: response.data.data,
            response
        };
    }
}
class GraphtonBaseReturnTypeBuilder {
    querySimpleFields = new Set([]);
    queryObjectFields = {};
    /**
     * Select all known fields te be returned
     */
    all() {
        this.querySimpleFields = new Set(this.availableSimpleFields);
        return this;
    }
    /**
     * Clear all selected fields.
     */
    clear() {
        this.querySimpleFields.clear();
        return this;
    }
    /**
     * Select `...fieldNames` to be returned
     */
    with(...fieldNames) {
        for (const fieldName of fieldNames) {
            if (!this.availableSimpleFields.has(fieldName)) {
                console.warn(`Field "${fieldName}" might not exist in type "${this.typeName}"!`);
            }
            this.querySimpleFields.add(fieldName);
        }
        return this;
    }
    /**
     * Remove `...fieldNames` from selection
     */
    without(...fieldNames) {
        for (const fieldName of fieldNames) {
            this.querySimpleFields.delete(fieldName);
        }
        return this;
    }
    /**
     * Alias for .all().without(...fieldNames)
     */
    except(...fieldNames) {
        return this.all().without(...fieldNames);
    }
    /**
     * Alias for .clear().with(...fieldNames)
     */
    only(...fieldNames) {
        return this.clear().with(...fieldNames);
    }
    /**
     * Add the `relatedType` OBJECT field, selecting the fields for that type using the `buildFields` closure
     */
    withRelated(relatedType, buildFields) {
        const relatedReturnType = new this.queryObjectFieldBuilders[relatedType]();
        buildFields(relatedReturnType);
        this.queryObjectFields[relatedType] = relatedReturnType;
        return this;
    }
    /**
     * Remove the `relatedType` OBJECT field
     * Selected fields for `relatedType` will be removed!
     */
    withoutRelated(relatedType) {
        delete this.queryObjectFields[relatedType];
        return this;
    }
    /**
     * Compile the selected fields to a GraphQL selection.
     */
    toReturnTypeString() {
        if (this.querySimpleFields.size < 1 && Object.values(this.queryObjectFields).length < 1) {
            return '';
        }
        const returnTypeString = ['{', ...this.querySimpleFields];
        for (const [objectType, objectField] of Object.entries(this.queryObjectFields)) {
            const objectFieldReturnTypeString = objectField.toReturnTypeString();
            if (objectFieldReturnTypeString.length > 0) {
                returnTypeString.push(objectType, objectFieldReturnTypeString);
            }
        }
        returnTypeString.push('}');
        return returnTypeString.join(' ');
    }
}
class UserReturnTypeBuilder extends GraphtonBaseReturnTypeBuilder {
    availableSimpleFields = new Set(["id", "name", "age"]);
    typeName = 'User';
    queryObjectFieldBuilders = { "posts": PostReturnTypeBuilder, "friends": UserReturnTypeBuilder };
}
class PostReturnTypeBuilder extends GraphtonBaseReturnTypeBuilder {
    availableSimpleFields = new Set(["id", "text"]);
    typeName = 'Post';
    queryObjectFieldBuilders = { "author": UserReturnTypeBuilder, "repatedPosts": PostReturnTypeBuilder };
}
// REGION: Queries
export class Query {
    static users() {
        return new UsersQuery();
    }
    static user(queryArgs) {
        return new UserQuery(queryArgs);
    }
    static userExists(queryArgs) {
        return new UserExistsQuery(queryArgs);
    }
}
class UsersQuery extends GraphtonBaseQuery {
    queryName = 'users';
    rootType = 'query';
    returnType = new UserReturnTypeBuilder();
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class UserQuery extends GraphtonBaseQuery {
    queryName = 'user';
    rootType = 'query';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class UserExistsQuery extends GraphtonBaseQuery {
    queryName = 'userExists';
    rootType = 'query';
    returnType = null;
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
// REGION: Mutations
export class Mutation {
    static createUser(queryArgs) {
        return new CreateUserMutation(queryArgs);
    }
    static updateUser(queryArgs) {
        return new UpdateUserMutation(queryArgs);
    }
    static deleteUser(queryArgs) {
        return new DeleteUserMutation(queryArgs);
    }
}
class CreateUserMutation extends GraphtonBaseQuery {
    queryName = 'createUser';
    rootType = 'mutation';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class UpdateUserMutation extends GraphtonBaseQuery {
    queryName = 'updateUser';
    rootType = 'mutation';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
class DeleteUserMutation extends GraphtonBaseQuery {
    queryName = 'deleteUser';
    rootType = 'mutation';
    returnType = new UserReturnTypeBuilder();
    constructor(queryArgs) {
        super();
        queryArgs && this.setArgs(queryArgs);
    }
    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    returnFields(returnFieldsClosure) {
        returnFieldsClosure(this.returnType);
        return this;
    }
    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions = {}) {
        return (await super.execute(requestOptions));
    }
}
