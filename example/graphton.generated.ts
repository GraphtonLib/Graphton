// FILE GENERATED BY GRAPHTON
// DO NOT EDIT - CHANGES WILL BE OVERWRITTEN

// REGION: Base classes
const settings = {
    defaultHeaders: {},
    defaultUrl: ''
}

export class GraphtonSettings {
    public static setDefaultHeaders(headers: Record<string, string>): void {
        settings.defaultHeaders = headers;
    }

    public static setDefaultUrl(defaultUrl: string): void {
        settings.defaultUrl = defaultUrl;
    }
}

import axios, {AxiosResponse} from "axios";

type GraphQLServerEndpoint = string;
type Headers = Record<string, string>;

interface RequestOptions {
    headers?: Headers,
    url?: GraphQLServerEndpoint
}
interface QueryResponse {
    data: Record<string, any>,
    response: AxiosResponse
}

 type RootType = 'query'|'mutation';

 abstract class GraphtonBaseQuery {
    protected abstract queryName: string;
    protected abstract arguments: Record<string, any>;
    protected abstract rootType: RootType;
    protected abstract returnType: GraphtonBaseReturnTypeBuilder | null;

    private toReturnTypeString(): string {
        if(this.returnType) {
            return `{ ${this.returnType.toReturnTypeString()} }`;
        }

        return '';
    }

    /**
     * Transform builder to graphql query string
     */
    public toQuery(): string {
        const queryArgs = Object.entries(this.arguments);
        let queryArgString: string = '';
        if (queryArgs.length > 0) {
            let queryArgItems: string[] = [];
            for (const [name, value] of queryArgs) {
                queryArgItems.push(`${name}: ${JSON.stringify(value)}`);
            }

            queryArgString = `(${queryArgItems.join(', ')})`;
        }

        return `${this.rootType} ${this.queryName} { ${this.queryName}${queryArgString} ${this.toReturnTypeString()} }`;
    }

    /**
     * Execute the query
     */
    protected async execute(requestOptions: RequestOptions = {}): Promise<QueryResponse> {
        let response = await axios.post(requestOptions?.url || settings.defaultUrl, {query: this.toQuery()}, {
            headers: {
                "Content-Type": "application/json",
                ...settings.defaultHeaders,
                ...requestOptions?.headers
            },
        });

        return {
            data: response.data.data,
            response
        }
    }
}

abstract class GraphtonBaseReturnTypeBuilder {
    protected abstract availableSimpleFields: Set<string>;
    protected abstract availableObjectFields: Record<string, new() => GraphtonBaseReturnTypeBuilder>;
    protected querySimpleFields: Set<string> = new Set([]);
    protected queryObjectFields: Record<string, GraphtonBaseReturnTypeBuilder> = {};
    protected abstract typeName: string;

    /**
     * Select all known fields te be returned
     */
    public all(): this {
        this.querySimpleFields = new Set(this.availableSimpleFields);
        return this;
    }

    /**
     * Clear all selected fields.
     */
    public clear(): this {
        this.querySimpleFields.clear();
        return this;
    }

    /**
     * Select `...fieldNames` to be returned
     */
    public with(...fieldNames: (string|string[])[]): this {
        const flatFieldNames = fieldNames.flat();
        for(const fieldName of flatFieldNames) {
            if(!this.availableSimpleFields.has(fieldName)) {
                console.warn(`Field "${fieldName}" might not exist in type "${this.typeName}"!`);
            }

            this.querySimpleFields.add(fieldName);
        }

        return this;
    }

    /**
     * Remove `...fieldNames` from selection
     */
    public without(...fieldNames: (string|string[])[]): this {
        const flatFieldNames = fieldNames.flat();
        for(const fieldName of flatFieldNames) {
            this.querySimpleFields.delete(fieldName);
        }

        return this;
    }

    /**
     * Alias for .all().without(...fieldNames)
     */
    public except(...fieldNames: (string|string[])[]): this {
        return this.all().without(...fieldNames);
    }

    /**
     * Alias for .clear().with(...fieldNames)
     */
    public only(...fieldNames: (string|string[])[]): this {
        return this.clear().with(...fieldNames);
    }

    /**
     * Add the `relatedType` OBJECT field, selecting the fields for that type using the `buildFields` closure
     */
    public withRelated(relatedType: string, buildFields: (r: GraphtonBaseReturnTypeBuilder) => void) {
        const relatedReturnTypeClass = this.availableObjectFields[relatedType];
        if(!relatedReturnTypeClass) {
            console.warn(`Trying to add related field ${relatedType} to type ${this.typeName} which does not exist. Ignoring!`);
            return;
        }

        const relatedReturnType = new relatedReturnTypeClass();
        buildFields(relatedReturnType);
        this.queryObjectFields[relatedType] = relatedReturnType;
    }

    /**
     * Remove the `relatedType` OBJECT field
     * Selected fields for `relatedType` will be removed!
     */
    public withoutRelated(relatedType: string): void {
        delete this.queryObjectFields[relatedType];
    }

    /**
     * Compile the selected fields to a GraphQL selection.
     */
    public toReturnTypeString(): string {
        if(this.querySimpleFields.size < 1 && Object.values(this.queryObjectFields).length < 1) {
            return ``;
        }

        let returnTypeString = ['{', ...this.querySimpleFields];

        for(const [objectType, objectField] of Object.entries(this.queryObjectFields)) {
            let objectFieldReturnTypeString = objectField.toReturnTypeString();
            if(objectFieldReturnTypeString.length > 0) {
                returnTypeString.push(objectType, objectFieldReturnTypeString);
            }
        }

        returnTypeString.push('}');

        return returnTypeString.join(' ');
    }
}

// REGION: Types
export interface User {
  id?: number,
  name?: string,
  age?: (number | null),
  posts?: Post[],
}
export interface Post {
  id?: number,
  author?: User,
  text?: string,
}

type UserReturnTypeSimpleField = "id"|"name"|"age";
type UserReturnTypeObjectField = "posts";

class UserReturnTypeBuilder extends GraphtonBaseReturnTypeBuilder {
    protected availableSimpleFields = new Set(["id","name","age"]);
    protected availableObjectFields = {"posts":PostReturnTypeBuilder};
    protected typeName = 'User';

    public with(...fieldNames: (UserReturnTypeSimpleField|UserReturnTypeSimpleField[])[]): this {
        return super.with(...fieldNames);
    }
    public without(...fieldNames: (UserReturnTypeSimpleField|UserReturnTypeSimpleField[])[]): this {
        return super.without(...fieldNames);
    }
    public except(...fieldNames: (UserReturnTypeSimpleField|UserReturnTypeSimpleField[])[]): this {
        return super.except(...fieldNames);
    }
    public only(...fieldNames: (UserReturnTypeSimpleField|UserReturnTypeSimpleField[])[]): this {
        return super.only(...fieldNames);
    }
    public withRelated(relatedType: UserReturnTypeObjectField, buildFields: (type: GraphtonBaseReturnTypeBuilder) => void) {
        return super.withRelated(relatedType, buildFields);
    }
    public withoutRelated(relatedType: UserReturnTypeObjectField) {
        return super.withoutRelated(relatedType);
    }
}

type PostReturnTypeSimpleField = "id"|"text";
type PostReturnTypeObjectField = "author";

class PostReturnTypeBuilder extends GraphtonBaseReturnTypeBuilder {
    protected availableSimpleFields = new Set(["id","text"]);
    protected availableObjectFields = {"author":UserReturnTypeBuilder};
    protected typeName = 'Post';

    public with(...fieldNames: (PostReturnTypeSimpleField|PostReturnTypeSimpleField[])[]): this {
        return super.with(...fieldNames);
    }
    public without(...fieldNames: (PostReturnTypeSimpleField|PostReturnTypeSimpleField[])[]): this {
        return super.without(...fieldNames);
    }
    public except(...fieldNames: (PostReturnTypeSimpleField|PostReturnTypeSimpleField[])[]): this {
        return super.except(...fieldNames);
    }
    public only(...fieldNames: (PostReturnTypeSimpleField|PostReturnTypeSimpleField[])[]): this {
        return super.only(...fieldNames);
    }
    public withRelated(relatedType: PostReturnTypeObjectField, buildFields: (type: GraphtonBaseReturnTypeBuilder) => void) {
        return super.withRelated(relatedType, buildFields);
    }
    public withoutRelated(relatedType: PostReturnTypeObjectField) {
        return super.withoutRelated(relatedType);
    }
}

// REGION: Queries
export class Query {
  public static users() {
    return new UsersQuery();
  }
  public static user(id?: (number | null)) {
    return new UserQuery(id);
  }
  public static userExists(id?: (number | null)) {
    return new UserExistsQuery(id);
  }
}

interface UsersQueryResponse {
    data: {
        users: User[]
    },
    response: AxiosResponse
}
class UsersQuery extends GraphtonBaseQuery {
    protected queryName = "users";
    protected arguments: Record<string, any> = {};
    protected rootType: RootType = "query";
    protected returnType = new UserReturnTypeBuilder();

    constructor() {
        super();
        this.arguments = {};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void) {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions: RequestOptions = {}): Promise<UsersQueryResponse> {
        return <UsersQueryResponse>(await super.execute(requestOptions));
    }

}

interface UserQueryResponse {
    data: {
        user?: (User | null)
    },
    response: AxiosResponse
}
class UserQuery extends GraphtonBaseQuery {
    protected queryName = "user";
    protected arguments: Record<string, any> = {};
    protected rootType: RootType = "query";
    protected returnType = new UserReturnTypeBuilder();

    constructor(id?: (number | null)) {
        super();
        this.arguments = {id};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void) {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions: RequestOptions = {}): Promise<UserQueryResponse> {
        return <UserQueryResponse>(await super.execute(requestOptions));
    }

}

interface UserExistsQueryResponse {
    data: {
        userExists: boolean
    },
    response: AxiosResponse
}
class UserExistsQuery extends GraphtonBaseQuery {
    protected queryName = "userExists";
    protected arguments: Record<string, any> = {};
    protected rootType: RootType = "query";
    protected returnType =  null;

    constructor(id?: (number | null)) {
        super();
        this.arguments = {id};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }

    /**
     * Execute the query and get the results
     * Only available on Query type requests
     */
    async get(requestOptions: RequestOptions = {}): Promise<UserExistsQueryResponse> {
        return <UserExistsQueryResponse>(await super.execute(requestOptions));
    }

}

// REGION: Mutations
export class Mutation {
  public static createUser(name: string, age?: (number | null)) {
    return new CreateUserMutation(name, age);
  }
  public static updateUser(id: number, name?: (string | null), age?: (number | null)) {
    return new UpdateUserMutation(id, name, age);
  }
  public static deleteUser(id: number) {
    return new DeleteUserMutation(id);
  }
}

interface CreateUserMutationResponse {
    data: {
        createUser: User
    },
    response: AxiosResponse
}
class CreateUserMutation extends GraphtonBaseQuery {
    protected queryName = "createUser";
    protected arguments: Record<string, any> = {};
    protected rootType: RootType = "mutation";
    protected returnType = new UserReturnTypeBuilder();

    constructor(name: string, age?: (number | null)) {
        super();
        this.arguments = {name, age};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void) {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions: RequestOptions = {}): Promise<CreateUserMutationResponse> {
        return <CreateUserMutationResponse>(await super.execute(requestOptions));
    }

}

interface UpdateUserMutationResponse {
    data: {
        updateUser: User
    },
    response: AxiosResponse
}
class UpdateUserMutation extends GraphtonBaseQuery {
    protected queryName = "updateUser";
    protected arguments: Record<string, any> = {};
    protected rootType: RootType = "mutation";
    protected returnType = new UserReturnTypeBuilder();

    constructor(id: number, name?: (string | null), age?: (number | null)) {
        super();
        this.arguments = {id, name, age};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void) {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions: RequestOptions = {}): Promise<UpdateUserMutationResponse> {
        return <UpdateUserMutationResponse>(await super.execute(requestOptions));
    }

}

interface DeleteUserMutationResponse {
    data: {
        deleteUser: User
    },
    response: AxiosResponse
}
class DeleteUserMutation extends GraphtonBaseQuery {
    protected queryName = "deleteUser";
    protected arguments: Record<string, any> = {};
    protected rootType: RootType = "mutation";
    protected returnType = new UserReturnTypeBuilder();

    constructor(id: number) {
        super();
        this.arguments = {id};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }

    /**
     * Function to build the required fields for that query
     * Only available if the return type is an OBJECT
     */
    public returnFields(returnFieldsClosure: (r: UserReturnTypeBuilder) => void) {
        returnFieldsClosure(this.returnType);
        return this;
    }

    /**
     * Do the mutation on the server
     * Only available on Mutation type requests
     */
    async do(requestOptions: RequestOptions = {}): Promise<DeleteUserMutationResponse> {
        return <DeleteUserMutationResponse>(await super.execute(requestOptions));
    }

}