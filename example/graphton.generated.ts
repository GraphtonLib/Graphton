// FILE GENERATED BY GRAPHTON
// DO NOT EDIT - CHANGES WILL BE OVERWRITTEN

// REGION: Types
export interface User {
  id?: number,
  name?: string,
}

// REGION: Base classes
const settings = {
    defaultHeaders: {},
    defaultUrl: ''
}

export const grapthtonSettings = {
    setDefaultHeaders(headers: Record<string, string>) {
        settings.defaultHeaders = headers;
    },
    setDefaultUrl(defaultUrl: string) {
        settings.defaultUrl = defaultUrl;
    }
}

import axios, {AxiosResponse} from "axios";

type GraphQLServerEndpoint = string;
type Headers = Record<string, string>;

interface RequestOptions {
    headers?: Headers,
    url?: GraphQLServerEndpoint
}
interface QueryResponse {
    data: Record<string, any>,
    response: AxiosResponse
}

abstract class GraphtonBaseQuery {
    protected availableFields: Set<string> = new Set([]);
    protected queryName: string = '';
    protected queryFields: Set<string> = new Set([]);
    protected arguments: Record<string, any> = {};
    protected rootType: 'query'|'mutation'|'' = '';

    /**
     * Add all known fields.
     */
    public allFields(): this {
        this.queryFields = new Set(this.availableFields);
        return this;
    }

    /**
     * Remove all fields.
     */
    public clearFields(): this {
        this.queryFields.clear();
        return this;
    }

    /**
     * Add multiple fields to the query.
     */
    public withFields(...fieldNames: (string|string[])[]): this {
        const flatFieldNames = fieldNames.flat();
        for(const fieldName of flatFieldNames) {
            if(!this.availableFields.has(fieldName)) {
                console.warn(`You are trying to query ${this.queryName} with a field named ${fieldName}, which might not exist!`);
            }

            this.queryFields.add(fieldName);
        }

        return this;
    }

    /**
     * Add a field to the query.
     */
    public withField(fieldName: string): this {
        return this.withFields(fieldName);
    }

    /**
     * Remove multiple fields from the query.
     */
    public withoutFields(...fieldNames: (string|string[])[]): this {
        const flatFieldNames = fieldNames.flat();
        for(const fieldName of flatFieldNames) {
            this.queryFields.delete(fieldName);
        }

        return this;
    }

    /**
     * Remove a field from the query.
     */
    public withoutField(fieldName: string): this {
        return this.withoutFields(fieldName);
    }

    /**
     * All of the fields, except these.
     */
    public except(...fieldNames: (string|string[])[]): this {
        return this.allFields().withoutFields(...fieldNames);
    }

    /**
     * Only the following fields, ignoring previously set fields.
     */
    public only(...fieldNames: (string|string[])[]): this {
        return this.clearFields().withFields(...fieldNames);
    }

    /**
     * Transform builder to graphql query string
     */
    public toQuery() {
        const queryArgs = Object.entries(this.arguments);
        let queryArgString: string = '';
        if (queryArgs.length > 0) {
            let queryArgItems: string[] = [];
            for (const [name, value] of queryArgs) {
                queryArgItems.push(`${name}: ${JSON.stringify(value)}`);
            }

            queryArgString = `(${queryArgItems.join(', ')})`;
        }

        return `${this.rootType} ${this.queryName} { ${this.queryName}${queryArgString} { ${[...this.queryFields].join(' ')} } }`;
    }

    /**
     * Execute the query
     */
    protected async execute(requestOptions: RequestOptions = {}) {
        let response = await axios.post(requestOptions?.url || settings.defaultUrl, {query: this.toQuery()}, {
            headers: {
                "Content-Type": "application/json",
                ...settings.defaultHeaders,
                ...requestOptions?.headers
            },
        });

        return {
            data: response.data.data,
            response
        }
    }
}


// REGION: Queries
class GraphtonQueryBuilderFactory {
  public static users() {
    return new UsersQuery();
  }
  public static user(id?: number | null) {
    return new UserQuery(id);
  }
}
export const query = new GraphtonQueryBuilderFactory();

type UsersQueryAvailableFields = "id"|"name";
interface UsersQueryResponse {
    data: User[],
    response: AxiosResponse
}
class UsersQuery extends GraphtonBaseQuery {
    protected availableFields: Set<string> = new Set(["id","name"]);
    protected queryName: string = 'users';
    // Builder essentials
    protected queryFields: Set<string> = new Set([]);
    protected arguments: Record<string, any> = {};
    protected rootType: 'query'|'mutation' = 'query';
    constructor() {
        super();
        this.arguments = {};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }
    withFields(...fieldNames: (UsersQueryAvailableFields|UsersQueryAvailableFields[])[]): this {
        return super.withFields(...fieldNames);
    }
    withField(fieldName: UsersQueryAvailableFields): this {
        return super.withField(fieldName);
    }
    withoutFields(...fieldNames: (UsersQueryAvailableFields|UsersQueryAvailableFields[])[]): this {
        return super.withoutFields(...fieldNames);
    }
    withoutField(fieldName: UsersQueryAvailableFields): this {
        return super.withoutField(fieldName);
    }
    except(...fieldNames: (UsersQueryAvailableFields|UsersQueryAvailableFields[])[]): this {
        return super.except(...fieldNames);
    }
    only(...fieldNames: (UsersQueryAvailableFields|UsersQueryAvailableFields[])[]): this {
        return super.only(...fieldNames);
    }
    async get(requestOptions: RequestOptions = {}): Promise<UsersQueryResponse> {
        return <UsersQueryResponse>(await super.execute());
    }
    
}


type UserQueryAvailableFields = "id"|"name";
interface UserQueryResponse {
    data?: User | null,
    response: AxiosResponse
}
class UserQuery extends GraphtonBaseQuery {
    protected availableFields: Set<string> = new Set(["id","name"]);
    protected queryName: string = 'user';
    // Builder essentials
    protected queryFields: Set<string> = new Set([]);
    protected arguments: Record<string, any> = {};
    protected rootType: 'query'|'mutation' = 'query';
    constructor(id?: number | null) {
        super();
        this.arguments = {id};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }
    withFields(...fieldNames: (UserQueryAvailableFields|UserQueryAvailableFields[])[]): this {
        return super.withFields(...fieldNames);
    }
    withField(fieldName: UserQueryAvailableFields): this {
        return super.withField(fieldName);
    }
    withoutFields(...fieldNames: (UserQueryAvailableFields|UserQueryAvailableFields[])[]): this {
        return super.withoutFields(...fieldNames);
    }
    withoutField(fieldName: UserQueryAvailableFields): this {
        return super.withoutField(fieldName);
    }
    except(...fieldNames: (UserQueryAvailableFields|UserQueryAvailableFields[])[]): this {
        return super.except(...fieldNames);
    }
    only(...fieldNames: (UserQueryAvailableFields|UserQueryAvailableFields[])[]): this {
        return super.only(...fieldNames);
    }
    async get(requestOptions: RequestOptions = {}): Promise<UserQueryResponse> {
        return <UserQueryResponse>(await super.execute());
    }
    
}



// REGION: Mutations
class GraphtonMutationBuilderFactory {
  public static createUser(name: string, pin: string) {
    return new CreateUserMutation(name, pin);
  }
  public static updateUser(id: number, name?: string | null, pin?: string | null) {
    return new UpdateUserMutation(id, name, pin);
  }
  public static deleteUser(id: number) {
    return new DeleteUserMutation(id);
  }
}
export const mutation = new GraphtonMutationBuilderFactory();

type CreateUserMutationAvailableFields = "id"|"name";
interface CreateUserMutationResponse {
    data: User,
    response: AxiosResponse
}
class CreateUserMutation extends GraphtonBaseQuery {
    protected availableFields: Set<string> = new Set(["id","name"]);
    protected queryName: string = 'createUser';
    // Builder essentials
    protected queryFields: Set<string> = new Set([]);
    protected arguments: Record<string, any> = {};
    protected rootType: 'query'|'mutation' = 'mutation';
    constructor(name: string, pin: string) {
        super();
        this.arguments = {name, pin};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }
    withFields(...fieldNames: (CreateUserMutationAvailableFields|CreateUserMutationAvailableFields[])[]): this {
        return super.withFields(...fieldNames);
    }
    withField(fieldName: CreateUserMutationAvailableFields): this {
        return super.withField(fieldName);
    }
    withoutFields(...fieldNames: (CreateUserMutationAvailableFields|CreateUserMutationAvailableFields[])[]): this {
        return super.withoutFields(...fieldNames);
    }
    withoutField(fieldName: CreateUserMutationAvailableFields): this {
        return super.withoutField(fieldName);
    }
    except(...fieldNames: (CreateUserMutationAvailableFields|CreateUserMutationAvailableFields[])[]): this {
        return super.except(...fieldNames);
    }
    only(...fieldNames: (CreateUserMutationAvailableFields|CreateUserMutationAvailableFields[])[]): this {
        return super.only(...fieldNames);
    }
    
    async do(requestOptions: RequestOptions = {}): Promise<CreateUserMutationResponse> {
        return <CreateUserMutationResponse>(await super.execute());
    }
}


type UpdateUserMutationAvailableFields = "id"|"name";
interface UpdateUserMutationResponse {
    data: User,
    response: AxiosResponse
}
class UpdateUserMutation extends GraphtonBaseQuery {
    protected availableFields: Set<string> = new Set(["id","name"]);
    protected queryName: string = 'updateUser';
    // Builder essentials
    protected queryFields: Set<string> = new Set([]);
    protected arguments: Record<string, any> = {};
    protected rootType: 'query'|'mutation' = 'mutation';
    constructor(id: number, name?: string | null, pin?: string | null) {
        super();
        this.arguments = {id, name, pin};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }
    withFields(...fieldNames: (UpdateUserMutationAvailableFields|UpdateUserMutationAvailableFields[])[]): this {
        return super.withFields(...fieldNames);
    }
    withField(fieldName: UpdateUserMutationAvailableFields): this {
        return super.withField(fieldName);
    }
    withoutFields(...fieldNames: (UpdateUserMutationAvailableFields|UpdateUserMutationAvailableFields[])[]): this {
        return super.withoutFields(...fieldNames);
    }
    withoutField(fieldName: UpdateUserMutationAvailableFields): this {
        return super.withoutField(fieldName);
    }
    except(...fieldNames: (UpdateUserMutationAvailableFields|UpdateUserMutationAvailableFields[])[]): this {
        return super.except(...fieldNames);
    }
    only(...fieldNames: (UpdateUserMutationAvailableFields|UpdateUserMutationAvailableFields[])[]): this {
        return super.only(...fieldNames);
    }
    
    async do(requestOptions: RequestOptions = {}): Promise<UpdateUserMutationResponse> {
        return <UpdateUserMutationResponse>(await super.execute());
    }
}


type DeleteUserMutationAvailableFields = "id"|"name";
interface DeleteUserMutationResponse {
    data: User,
    response: AxiosResponse
}
class DeleteUserMutation extends GraphtonBaseQuery {
    protected availableFields: Set<string> = new Set(["id","name"]);
    protected queryName: string = 'deleteUser';
    // Builder essentials
    protected queryFields: Set<string> = new Set([]);
    protected arguments: Record<string, any> = {};
    protected rootType: 'query'|'mutation' = 'mutation';
    constructor(id: number) {
        super();
        this.arguments = {id};
        Object.keys(this.arguments).forEach(key => this.arguments[key] === undefined && delete this.arguments[key]);
    }
    withFields(...fieldNames: (DeleteUserMutationAvailableFields|DeleteUserMutationAvailableFields[])[]): this {
        return super.withFields(...fieldNames);
    }
    withField(fieldName: DeleteUserMutationAvailableFields): this {
        return super.withField(fieldName);
    }
    withoutFields(...fieldNames: (DeleteUserMutationAvailableFields|DeleteUserMutationAvailableFields[])[]): this {
        return super.withoutFields(...fieldNames);
    }
    withoutField(fieldName: DeleteUserMutationAvailableFields): this {
        return super.withoutField(fieldName);
    }
    except(...fieldNames: (DeleteUserMutationAvailableFields|DeleteUserMutationAvailableFields[])[]): this {
        return super.except(...fieldNames);
    }
    only(...fieldNames: (DeleteUserMutationAvailableFields|DeleteUserMutationAvailableFields[])[]): this {
        return super.only(...fieldNames);
    }
    
    async do(requestOptions: RequestOptions = {}): Promise<DeleteUserMutationResponse> {
        return <DeleteUserMutationResponse>(await super.execute());
    }
}


