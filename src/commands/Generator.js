import { fillStub, isUrl } from "../helpers/helpers.js";
import axios from "axios";
import { introspectQuery } from "../graphql/query/introspect.js";
import * as fs from "fs";
import { pascalCase } from "change-case";
const scalarMap = (scalarType) => ({
    'Int': 'number',
    'Boolean': 'boolean',
    'String': 'string',
    'ID': 'number',
    'DateTime': 'string',
    'Date': 'string',
    'Time': 'string',
})[scalarType] || scalarType;
export default class Generator {
    gqlSchema = null;
    async generate(schemaUri, options) {
        let outContentSections = [];
        try {
            if (isUrl(schemaUri)) {
                this.gqlSchema = (await axios.post(schemaUri, { query: introspectQuery }))?.data?.data?.__schema;
            }
            else if (fs.existsSync(schemaUri)) {
                this.gqlSchema = JSON.parse(fs.readFileSync(schemaUri, { encoding: "utf8" }));
            }
        }
        catch (_) {
            this.gqlSchema = null;
        }
        if (!this.gqlSchema) {
            console.error(`Could not decode json schema from ${schemaUri}`);
            process.exit(1);
        }
        let ignoreTypes = [
            this.gqlSchema.queryType?.name,
            this.gqlSchema.mutationType?.name,
            this.gqlSchema.subscriptionType?.name,
        ];
        let types = this.gqlSchema.types
            .filter(type => type.kind === 'OBJECT' && !type.name.startsWith("__") && ignoreTypes.indexOf(type.name) < 0);
        outContentSections.push(...[
            '// FILE GENERATED BY GRAPHTON',
            '// DO NOT EDIT - CHANGES WILL BE OVERWRITTEN',
            ''
        ]);
        console.log('Generating types...');
        outContentSections.push(...[
            '// REGION: Types',
            ...this.generateTypes(types),
            ``,
        ]);
        console.log('Adding base classes...');
        outContentSections.push(...[
            '// REGION: Base classes',
            fillStub('Settings', { "DEFAULTPOSTURL": isUrl(schemaUri) ? schemaUri : '' }),
            fillStub('GraphtonBaseQuery'),
            ``,
        ]);
        console.log('Generating query classes...');
        outContentSections.push(...[
            '// REGION: Queries',
            ...this.generateQueries(this.gqlSchema.types.find(t => t.name === this.gqlSchema?.queryType?.name)?.fields || [], options.queryRootName),
            ``,
        ]);
        fs.writeFileSync(options.outputFile, outContentSections.join("\n"), { encoding: "utf8" });
    }
    *generateTypes(types) {
        for (let type of types) {
            yield `export interface ${type.name} {`;
            yield* this.generateFields(type.fields);
            yield `}`;
        }
    }
    *generateFields(fields) {
        for (let field of fields) {
            yield `  ${field.name}${Generator.toTypeAppend(field.type)}`;
        }
    }
    *generateQueries(queries, queryRootName = 'query') {
        yield `class GraphtonQueryBuilder {`;
        for (let query of queries) {
            const args = [];
            const argNames = [];
            for (let arg of query.args) {
                args.push(`${arg.name}${Generator.toTypeAppend(arg.type)}${arg.defaultValue ? ` = ${JSON.stringify(arg.defaultValue)}` : ''}`);
                argNames.push(arg.name);
            }
            yield `  public static ${query.name}(${args.join(', ')}) {`;
            yield `    return new ${pascalCase(query.name)}Query(${argNames.join(', ')});`;
            yield `  }`;
        }
        yield `}`;
        yield `export const ${queryRootName} = new GraphtonQueryBuilder();`;
        yield ``;
        for (let query of queries) {
            yield this.generateQueryClass(query);
            yield ``;
        }
    }
    generateQueryClass(query) {
        let returnType = Generator.findReturnType(query.type);
        let fieldNames = this.gqlSchema?.types.find(t => t.name == returnType)?.fields.map(f => f.name) || [];
        return fillStub('Query', {
            "QUERYCLASSNAME": `${pascalCase(query.name)}Query`,
            "FIELDS": JSON.stringify(fieldNames),
            "FIELDSTUPLE": fieldNames.map(f => JSON.stringify(f)).join('|'),
            "QUERYNAME": query.name,
        });
    }
    static findReturnType(type) {
        if (type?.kind === 'OBJECT') {
            return type.name;
        }
        if (type?.ofType?.kind === 'OBJECT') {
            return type.ofType.name;
        }
        if (type?.ofType?.ofType?.kind === 'OBJECT') {
            return type.ofType.ofType.name;
        }
        if (type?.ofType?.ofType?.ofType?.kind === 'OBJECT') {
            return type.ofType.ofType.ofType.name;
        }
        return null;
    }
    static toTypeAppend(type) {
        let currentType = type || null;
        if (!currentType) {
            return ``;
        }
        const directTypes = ['OBJECT', 'SCALAR', 'ENUM'];
        const nonNullTypes = ['NON_NULL'];
        const listTypes = ['LIST'];
        if (directTypes.indexOf(currentType.kind) > -1) {
            return `?: ${scalarMap(currentType.name)},`;
        }
        if (nonNullTypes.indexOf(currentType.kind) > -1 && currentType.ofType) {
            currentType = currentType.ofType;
            if (directTypes.indexOf(currentType.kind) > -1) {
                return `: ${scalarMap(currentType.name)},`;
            }
            if (listTypes.indexOf(currentType.kind) > -1 && currentType.ofType) {
                currentType = currentType.ofType;
                if (directTypes.indexOf(currentType.kind) > -1) {
                    return `: ${scalarMap(currentType.name)}?[],`;
                }
                if (nonNullTypes.indexOf(currentType.kind) > -1 && currentType.ofType) {
                    currentType = currentType.ofType;
                    return `: ${scalarMap(currentType.name)}[],`;
                }
            }
        }
        return ``;
    }
}
